<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>My Colab Notebooks</title>
  <link rel="stylesheet" href="assets/style.css" />
  <script defer src="config.js?v=1"></script>



 

  <!-- Lite modal styles (inline so you don't have to touch style.css) -->
  <style>
    /* JupyterLite modal */
    .lite-modal{position:fixed;inset:0;background:rgba(0,0,0,.35);display:none;align-items:center;justify-content:center;z-index:9999}
    .lite-modal.open{display:flex}
    .lite-dialog{width:min(1100px,95vw);height:min(700px,85vh);background:#fff;border-radius:16px;overflow:hidden;box-shadow:0 10px 30px rgba(0,0,0,.25);position:relative}
    .lite-iframe{width:100%;height:100%;border:0}
    .lite-close{position:absolute;top:8px;right:8px;border:0;background:#fff;padding:.45rem .7rem;border-radius:999px;box-shadow:0 1px 3px rgba(0,0,0,.15);cursor:pointer}
    .lite-help{position:absolute;left:12px;top:12px;background:#fff;padding:.35rem .6rem;border-radius:10px;font-size:.85rem;box-shadow:0 1px 3px rgba(0,0,0,.15)}
  </style>

  <script>
  async function loadList() {
    const ul = document.querySelector('#notebook-list');
    try {
    if (!window.SITE || !SITE.user || !SITE.repo) {
      ul.innerHTML = '<li>config.js missing or incomplete (need SITE.user and SITE.repo).</li>';
      return;
    }

      const user = SITE.user;
      const repo = SITE.repo;
      const branch = SITE.branch || 'main';
      //const api = `https://api.github.com/repos/${user}/${repo}/contents/ipynb?ref=${branch}`;
      const api = `https://api.github.com/repos/${encodeURIComponent(user)}/${encodeURIComponent(repo)}/contents/ipynb?ref=${encodeURIComponent(branch)}`;

      const res = await fetch(api, { headers: { 'Accept': 'application/vnd.github+json' }});
      if (!res.ok) throw new Error(`GitHub API returned ${res.status}`);
      const data = await res.json();
      const items = Array.isArray(data) ? data : [];
      ul.innerHTML = '';

      for (const it of items) {
        if (!it.name.endsWith('.ipynb')) continue;
        const base = it.name.replace(/\.ipynb$/, '');
        const htmlUrl   = `notebooks/${base}.html`;
        const colabUrl  = `https://colab.research.google.com/github/${user}/${repo}/blob/${branch}/ipynb/${encodeURIComponent(it.name)}`;
        const ghUrl     = `https://github.com/${user}/${repo}/blob/${branch}/ipynb/${encodeURIComponent(it.name)}`;
        // JupyterLab 4+: use labpath
        const binderUrl = `https://mybinder.org/v2/gh/${user}/${repo}/${branch}?labpath=ipynb/${encodeURIComponent(it.name)}`;
        // Raw URL for JupyterLite open-from-URL
        const rawUrl    = `https://raw.githubusercontent.com/${user}/${repo}/${branch}/ipynb/${encodeURIComponent(it.name)}`;

        // Card
        const card = document.createElement('li');
        card.className = 'card';

        // Header (collapsible)
        const header = document.createElement('div');
        header.className = 'card-header';
        header.innerHTML = `<span class="card-title">${it.name}</span><span class="arrow">▶</span>`;
        card.appendChild(header);

        // Body
        const body = document.createElement('div');
        body.className = 'card-body';

        // Badges
        const badgesEl = document.createElement('div');
        badgesEl.className = 'badges';
        badgesEl.id = `badges-${base}`;
        body.appendChild(badgesEl);

        // Actions
        const actionsEl = document.createElement('div');
        actionsEl.className = 'card-actions';
        actionsEl.innerHTML = `
          <a class="btn" href="${htmlUrl}" target="_blank" rel="noopener">View HTML</a>
          <a class="btn" href="${colabUrl}" target="_blank" rel="noopener">
            <img alt="Open in Colab" src="https://colab.research.google.com/assets/colab-badge.svg" style="height:1.1em;vertical-align:middle" />
            <span>Open in Colab</span>
          </a>
          <a class="btn" href="${binderUrl}" target="_blank" rel="noopener">
            <img alt="Launch in Binder" src="https://mybinder.org/badge_logo.svg" style="height:1.1em;vertical-align:middle" />
            <span>Run in Binder</span>
          </a>
          <a class="btn" href="${ghUrl}" target="_blank" rel="noopener">View on GitHub</a>
        `;
        body.appendChild(actionsEl);

        // Live + Save buttons
        const liveBtn = document.createElement('button');
        liveBtn.className = 'btn live-btn';
        liveBtn.dataset.target = base;
        liveBtn.textContent = 'Make Live';
        actionsEl.appendChild(liveBtn);

        const saveBtn = document.createElement('button');
        saveBtn.className = 'btn save-btn';
        saveBtn.dataset.target = base;
        saveBtn.textContent = 'Save to GitHub';
        actionsEl.appendChild(saveBtn);

        // Expand height button
        const expandBtn = document.createElement('button');
        expandBtn.className = 'btn expand-btn';
        expandBtn.dataset.target = base;
        expandBtn.textContent = 'Expand Preview';
        actionsEl.appendChild(expandBtn);

        // Binder-free (JupyterLite) button
        const liteBtn = document.createElement('button');
        liteBtn.className = 'btn';
        liteBtn.textContent = 'Run in Browser (Lite)';
        liteBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          openLiteWith(rawUrl);
        });
        actionsEl.appendChild(liteBtn);

        // Preview wrapper (iframe + TOC)
        const preview = document.createElement('div');
        preview.className = 'preview-wrapper';
        preview.innerHTML = `
          <iframe class="frame" id="frame-${base}" src="${htmlUrl}" loading="lazy"></iframe>
          <aside class="toc" id="toc-${base}">
            <h3>Contents</h3>
            <div class="toc-body">Loading…</div>
          </aside>
        `;
        body.appendChild(preview);

        // Assemble
        card.appendChild(body);
        ul.appendChild(card);

        // Collapse toggle
        header.addEventListener('click', () => {
          const arrowEl = header.querySelector('.arrow');
          const isOpen = card.classList.toggle('open');
          arrowEl.textContent = isOpen ? '▼' : '▶';
        });

        // Expand height
     // Expand height (safer with null check)
const iframe = preview.querySelector(`#frame-${base}`);
const tocEl = preview.querySelector('.toc');
expandBtn.addEventListener('click', (e) => {
  e.stopPropagation();
  const btn = e.currentTarget;
  const expanded = btn.dataset.expanded === '1';
  iframe.style.height = expanded ? '500px' : '1000px';
  if (tocEl) tocEl.style.height = expanded ? '500px' : '1000px';
  btn.textContent = expanded ? 'Expand Preview' : 'Collapse Preview';
  btn.dataset.expanded = expanded ? '0' : '1';
});


        // Badges
        await addBadges(it, base);

        // TOC + copy + detect code cells
        iframe.addEventListener('load', () => {
          const tocBox = preview.querySelector('.toc-body');
          const hasCode = handleIframe(iframe, tocBox);

          // Disable/enable Make Live depending on code presence
          const liveBtnForThis = actionsEl.querySelector(`.live-btn[data-target="${base}"]`);
          if (liveBtnForThis) {
            if (!hasCode) {
              liveBtnForThis.disabled = true;
              liveBtnForThis.title = 'No code cells detected in this notebook';
            } else {
              liveBtnForThis.disabled = false;
              liveBtnForThis.removeAttribute('title');
            }
          }
        });

        // Live + Save handlers
        liveBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          initLive(e.currentTarget.dataset.target);
        });
        saveBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          saveNotebookToGitHub(e.currentTarget.dataset.target);
        });
      }

      if (!ul.children.length) {
        ul.innerHTML = '<li>No notebooks found yet. Add .ipynb files to /ipynb/ and push.</li>';
      }
    } catch (err) {
      ul.innerHTML = `<li>Could not load list. Error: ${err.message}</li>`;
    }
  }

  // Badges
  async function addBadges(item, base) {
    const wrap = document.getElementById(`badges-${base}`);
    if (!wrap) return;

const cacheKey = `lastCommit:${SITE.user}/${SITE.repo}/${item.name}`;
const cached = sessionStorage.getItem(cacheKey);
if (cached) {
  wrap.insertAdjacentHTML('beforeend', `<span class="badge">${cached}</span>`);
  return;
}

    
    if (typeof item.size === 'number') {
      const kb = (item.size / 1024).toFixed(1) + ' KB';
      wrap.insertAdjacentHTML('beforeend', `<span class="badge">${kb}</span>`);
    }
    wrap.insertAdjacentHTML('beforeend', `<span class="badge">python</span>`);

    try {
      const pathParam = encodeURIComponent(`ipynb/${item.name}`);
      const apiUrl = `https://api.github.com/repos/${SITE.user}/${SITE.repo}/commits?path=${pathParam}&page=1&per_page=1`;
      const resp = await fetch(apiUrl, { headers: { 'Accept': 'application/vnd.github+json' } });
      if (resp.ok) {
        const commitData = await resp.json();
        const d = commitData?.[0]?.commit?.committer?.date;
        if (d) {
          const s = new Date(d).toLocaleString('en-US', { timeZone: 'America/Chicago' });
          wrap.insertAdjacentHTML('beforeend', `<span class="badge">${s}</span>`);
          sessionStorage.setItem(cacheKey, s);

          return;
        }
      }
    } catch (_) {}

    const fallback = new Date().toLocaleString('en-US', { timeZone: 'America/Chicago' });
    wrap.insertAdjacentHTML('beforeend', `<span class="badge">${fallback}</span>`);
  }

  // Build TOC + copy buttons inside iframe; return whether code cells exist
  function handleIframe(iframe, tocBox) {
    const doc = iframe.contentDocument || iframe.contentWindow.document;
    if (!doc) { tocBox.textContent = 'Unable to read preview.'; return false; }

    // Only target code *inputs* (avoid outputs and generic <pre>)
    const inputSelectors = '.input_area pre, .jp-Cell .jp-InputArea-editor';
    const hasCode = !!doc.querySelector(inputSelectors);

    // Mark code inputs for Thebe (idempotent)
    try {
      const codeInputs = doc.querySelectorAll(inputSelectors);
      codeInputs.forEach((el) => {
        const host = el.closest('pre') || el;
        if (!host.dataset.thebeAdded) {
          host.dataset.thebeAdded = '1';
          host.setAttribute('data-executable', 'true');
          host.setAttribute('data-language', 'python');
        }
      });
    } catch {}

    // TOC
let headings = doc.querySelectorAll(
  '.text_cell_render h1, .text_cell_render h2, .text_cell_render h3, ' +
  '.jp-RenderedHTMLCommon h1, .jp-RenderedHTMLCommon h2, .jp-RenderedHTMLCommon h3, ' +
  'h1, h2, h3'
);

    headings = Array.from(headings).filter(h => h.textContent.trim().length > 0);
    if (!headings.length) {
      tocBox.textContent = 'No headings detected.';
    } else {
      const list = document.createElement('div');
      headings.forEach((h, i) => {
        if (!h.id) h.id = 'nb-h-' + i;
        const a = document.createElement('a');
        a.href = '#' + h.id;
        a.textContent = h.textContent.trim();
        const lvl = h.tagName.toLowerCase();
        a.style.marginLeft = (lvl === 'h2' ? '12px' : lvl === 'h3' ? '24px' : '0');
        a.addEventListener('click', ev => { ev.preventDefault(); h.scrollIntoView({behavior:'smooth', block:'start'}); });
        list.appendChild(a);
      });
      tocBox.innerHTML = '';
      tocBox.appendChild(list);
    }

    // Copy buttons (overlay; do NOT wrap the <pre>, to avoid breaking Thebe)
    const areas = doc.querySelectorAll('div.input_area');
    areas.forEach(area => {
      if (area.querySelector('.nb-copy-btn')) return;
      area.style.position = area.style.position || 'relative';
      const btn = doc.createElement('button');
      btn.className = 'nb-copy-btn';
      btn.textContent = 'Copy';
      btn.style.cssText = 'position:absolute;right:8px;top:8px;font-size:12px;border:1px solid #ccc;background:#f6f6f6;padding:2px 6px;border-radius:4px;cursor:pointer;';
      btn.addEventListener('click', async () => {
        const pre = area.querySelector('pre');
        const text = pre ? pre.innerText : '';
        try { await navigator.clipboard.writeText(text); btn.textContent = 'Copied!'; }
        catch { btn.textContent = 'Failed'; }
        setTimeout(() => (btn.textContent = 'Copy'), 1200);
      });
      area.appendChild(btn);
    });

    return hasCode;
  }

  document.addEventListener('DOMContentLoaded', loadList);

  // Make Live: inject Thebe into the iframe and bootstrap there
  async function initLive(baseName) {
    const iframe = document.getElementById('frame-' + baseName);
    const doc = iframe?.contentDocument || iframe?.contentWindow?.document;
    if (!doc) { alert('Preview not ready.'); return; }

    // If we already went live once for this iframe, do nothing (prevents duplicates)
    if (doc.body.dataset.thebeBootstrapped === '1') {
      console.log('[thebe] already bootstrapped for', baseName);
      return;
    }

    // Only count code *inputs*
    const inputSelectors = '.input_area pre, .jp-Cell .jp-InputArea-editor';
    const candidates = doc.querySelectorAll(inputSelectors);
    if (!candidates.length) { alert('No code cells found in this notebook.'); return; }

    // Ensure inputs are marked
    candidates.forEach(el => {
      const host = el.closest('pre') || el;
      if (!host.dataset.executable) host.setAttribute('data-executable', 'true');
      if (!host.dataset.language)   host.setAttribute('data-language', 'python');
    });

    // Load thebe.js into the iframe (absolute URL so it doesn't 404 from /notebooks/)
    const basePath = location.pathname.endsWith('/')
      ? location.pathname
      : location.pathname.replace(/[^/]+$/, '/');
    const thebeSrc = `${location.origin}${basePath}assets/thebe.js`;

    await new Promise((resolve, reject) => {
      if (doc.defaultView.thebe) return resolve();
      const s = doc.createElement('script');
      s.src = thebeSrc;
      s.onload = resolve;
      s.onerror = () => reject(new Error('Failed to load thebe.js inside iframe'));
      doc.head.appendChild(s);
    });

    // Configure Thebe; disable splash (prevents extra tab)
    doc.defaultView.thebe_config = {
      binderOptions: {
        repo: `${SITE.user}/${SITE.repo}`,
        ref: SITE.branch || 'main',
        binderUrl: 'https://mybinder.org'
      },
      selector: '[data-executable]',
      requestKernel: true,
      useBinderSplash: false,   // no extra tab
      kernelName: 'python3'
    };

    try {
      await doc.defaultView.thebe.bootstrap();
      doc.body.dataset.thebeBootstrapped = '1';
      console.log('[thebe] bootstrapped for', baseName);
    } catch (e) {
      console.error(e);
      alert('Failed to start Thebe (Binder). Check network/Binder status.');
    }
  }

  // Save back to GitHub
  async function saveNotebookToGitHub(baseName) {
    try {
      const token = prompt('Enter your GitHub Personal Access Token (PAT) with repo write access:');
      if (!token) { alert('Save cancelled. No token provided.'); return; }

      const owner = SITE.user;
      const repo = SITE.repo;
      const branch = SITE.branch || 'main';
      const filename = `${baseName}.ipynb`;
      const path = `ipynb/${filename}`;

      const metaResp = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${path}?ref=${branch}`, {
        headers: { 'Accept': 'application/vnd.github+json', 'Authorization': `Bearer ${token}` }
      });
      if (!metaResp.ok) throw new Error('Failed to fetch notebook metadata.');
      const meta = await metaResp.json();
      const sha = meta.sha;
// decode base64 → Uint8Array → UTF‑8 string
const bin = Uint8Array.from(atob(meta.content.replace(/\n/g, '')), c => c.charCodeAt(0));
const originalContent = new TextDecoder('utf-8').decode(bin);
let nb = JSON.parse(originalContent);

// encode UTF‑8 safely back to base64
const updatedBytes = new TextEncoder().encode(JSON.stringify(nb, null, 1));
let updatedBase64 = '';
for (let i = 0; i < updatedBytes.length; i += 0x8000) {
  updatedBase64 += btoa(String.fromCharCode.apply(null, updatedBytes.subarray(i, i + 0x8000)));
}



      const putResp = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${path}`, {
        method: 'PUT',
        headers: {
          'Accept': 'application/vnd.github+json',
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ message: `Update ${filename} via interactive site`, content: updatedBase64, sha, branch })
      });
      if (!putResp.ok) throw new Error('Failed to commit notebook.');

      alert(`Notebook ${filename} saved successfully to GitHub.`);
      iframe.src = iframe.src;
    } catch (err) {
      console.error(err);
      alert(err.message || 'An error occurred while saving the notebook.');
    }
  }

  // ----- JupyterLite modal helpers -----
  function ensureLiteModal() {
    let modal = document.getElementById('lite-modal');
    if (modal) return modal;

    modal = document.createElement('div');
    modal.id = 'lite-modal';
    modal.className = 'lite-modal';
modal.innerHTML = `
  <div class="lite-dialog">
    <button class="lite-close" aria-label="Close">✕</button>
    <div class="lite-help">
      <button class="lite-help-close" aria-label="Hide tip">✕</button>
      JupyterLite opened. Tip: drag & drop your .ipynb, or
      <b>File → Open from URL</b> (URL already copied to your clipboard).
    </div>
    <iframe class="lite-iframe" src="about:blank"></iframe>
  </div>`;

  const help = modal.querySelector('.lite-help');
const helpClose = modal.querySelector('.lite-help-close');
helpClose.addEventListener('click', () => { help.style.display = 'none'; });

// optional auto-hide after 6s:
 setTimeout(() => { help.style.display = 'none'; }, 6000);

    
    document.body.appendChild(modal);

    modal.querySelector('.lite-close').addEventListener('click', () => modal.classList.remove('open'));
    modal.addEventListener('click', (e) => { if (e.target === modal) modal.classList.remove('open'); });
    return modal;
  }

  function openLiteWith(rawUrl) {
    const modal = ensureLiteModal();
    const iframe = modal.querySelector('iframe');
    // Open official JupyterLite Lab (browser-only Python)
    iframe.src = 'https://jupyterlite.github.io/demo/lab/index.html';
    modal.classList.add('open');

    // Copy the notebook URL so user can paste in “Open from URL”
    if (navigator.clipboard?.writeText) {
      navigator.clipboard.writeText(rawUrl).catch(() => {});
    }
  }
  // ----- end JupyterLite helpers -----
  </script>
</head>
<body>
  <header>
    <h1>My Colab Notebooks</h1>
    <p>Static HTML previews plus one-click launch in Colab.</p>
  </header>
  <main>
    <ul id="notebook-list" class="grid"></ul>
  </main>
  <footer>
    <p>Powered by GitHub Pages & nbconvert.</p>
  </footer>
</body>
</html>
